% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/crossval_ts.R
\name{crossval_ts}
\alias{crossval_ts}
\title{Generic cross-validation function for time series}
\usage{
crossval_ts(
  y,
  x = NULL,
  fit_func = crossvalidation::fit_lm,
  predict_func = crossvalidation::predict_lm,
  fcast_func = NULL,
  fit_params = NULL,
  p = 1,
  initial_window = 5,
  horizon = 3,
  fixed_window = TRUE,
  level = c(80, 95),
  seed = 123,
  eval_metric = NULL,
  cl = NULL,
  errorhandling = c("stop", "remove", "pass"),
  packages = c("stats", "Rcpp"),
  verbose = FALSE,
  show_progress = TRUE,
  ...
)
}
\arguments{
\item{y}{response time series; a vector or a matrix}

\item{x}{input covariates' matrix (optional) for ML models}

\item{fit_func}{a function for fitting the model (if validation of ML model)}

\item{predict_func}{a function for predicting values from the model (if validation of ML model)}

\item{fcast_func}{time series forecasting function (e.g forecast::thetaf)}

\item{fit_params}{a list; additional (model-specific) parameters to be passed
to \code{fit_func}}

\item{p}{a float; percentage of original data in the training/testing procedure, default is 1 and
must be > 0.5.}

\item{initial_window}{an integer; the initial number of consecutive values in each training set sample}

\item{horizon}{an integer; the number of consecutive values in test set sample}

\item{fixed_window}{a boolean; if FALSE, all training samples start at 1}

\item{level}{a numeric vector; confidence levels for prediction intervals.}

\item{seed}{random seed for reproducibility of results}

\item{eval_metric}{a function measuring the test errors; if not provided: RMSE for regression and
accuracy for classification}

\item{cl}{an integer; the number of clusters for parallel execution}

\item{errorhandling}{specifies how a task evalution error should be handled.
If value is "stop", then execution will be stopped if an error occurs. If value
is "remove", the result for that task will not be returned. If value is "pass",
then the error object generated by task evaluation will be included with the
rest of the results. The default value is "stop".}

\item{packages}{character vector of packages that the tasks depend on}

\item{verbose}{logical flag enabling verbose messages. This can be very useful for
troubleshooting.}

\item{show_progress}{show evolution of the algorithm}

\item{...}{additional parameters}
}
\description{
Generic cross-validation for univariate and multivariate time series
}
\examples{


require(forecast)
data("AirPassengers")

# Example 1 -----

res <- crossval_ts(y=AirPassengers, initial_window = 10,
horizon = 3, fcast_func = forecast::thetaf)
print(colMeans(res))


# Example 2 -----

\dontrun{
fcast_func <- function (y, h, ...)
{
      forecast::forecast(forecast::auto.arima(y, ...),
      h=h, ...)
}

res <- crossval_ts(y=AirPassengers, initial_window = 10, horizon = 3,
fcast_func = fcast_func)
print(colMeans(res))
}


# Example 3 -----

fcast_func <- function (y, h, ...)
{
      forecast::forecast(forecast::ets(y, ...),
      h=h, ...)
}

res <- crossval_ts(y=AirPassengers,
initial_window = 10, horizon = 3, fcast_func = fcast_func)
print(colMeans(res))


# Example 4 -----

xreg <- cbind(1, 1:length(AirPassengers))
res <- crossval_ts(y=AirPassengers, x=xreg, fit_func = crossvalidation::fit_lm,
predict_func = crossvalidation::predict_lm,
initial_window = 10,
horizon = 3,
fixed_window = TRUE)
print(colMeans(res))


# Example 5 -----

res <- crossval_ts(y=AirPassengers, fcast_func = forecast::thetaf,
initial_window = 10,
horizon = 3,
fixed_window = TRUE)
print(colMeans(res))


#' # Example 6 -----

xreg <- cbind(1, 1:length(AirPassengers))
res <- crossval_ts(y=AirPassengers, x=xreg, fit_func = crossvalidation::fit_lm,
predict_func = crossvalidation::predict_lm,
initial_window = 10,
horizon = 3,
fixed_window = TRUE)
print(colMeans(res))


# Example 7 -----

x <- ts(matrix(rnorm(50), nrow = 25))

fcast_func <- function(y, h = 5, type_forecast=c("mean", "median"))
{
 type_forecast <- match.arg(type_forecast)

 if (type_forecast == "mean")
 {
  means <- colMeans(y)
  return(list(mean = t(replicate(n = h, expr = means))))
 } else {
  medians <- apply(y, 2, median)
  return(list(mean = t(replicate(n = h, expr = medians))))
 }

}

print(fcast_func(x))

res <- crossval_ts(y = x, fcast_func = fcast_func, fit_params = list(type_forecast = "median"))
colMeans(res)

res <- crossval_ts(y = x, fcast_func = fcast_func, fit_params = list(type_forecast = "mean"))
colMeans(res)

# Example 8 -----

eval_metric <- function(predicted, observed)
{
  error <- observed - predicted

  res <- apply(error, 2, function(x) sqrt(mean(x ^ 2, na.rm = FALSE)))

  return(res)
}

res <- crossval_ts(y = x, fcast_func = fcast_func, fit_params = list(type_forecast = "mean"),
eval_metric = eval_metric)

colMeans(res)

}
